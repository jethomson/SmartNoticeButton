<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <meta http-equiv="Cache-Control" content="private, no-store" />
  <title>Notification Events</title>
  <style>


  html {
    touch-action: manipulation;
    overflow: auto;
  }

  body {
    font-family: Arial, sans-serif;
    color: #faffff;
    background: #111;
    font-size: 17px;
    text-align: center;
    -webkit-touch-callout: none;
    -webkit-tap-highlight-color: transparent;
  }

  #return_main_menu {
    float: left;
  }
  
  #main_div {
    /*max-width: 1400px;*/
    margin: 0 auto;
  }

  .grid-container {
    display: grid;
    /*grid-template-columns: repeat(11, minmax(20px, 340px));*/ /*fixes select element overflow grid width problem in chrome*/
    grid-template-columns: repeat(13, auto);
    grid-column-gap: 1vw;
    grid-auto-rows: 30px;
    grid-row-gap: 5px;
    /*width: 1000px;*/
    max-width: 95vw;
    justify-content: center;
    justify-items: center;
    margin: 5px auto;
    padding: 5px;
    border-style: solid;
  }

  .item-a {
    grid-column-start: 1;
  }

  .grid-row {
    display: contents; /* Makes the wrapper invisible in grid layout */
  }
  /* this allows children element of section to be displayed as if they were direct children of the div grid */
  section {
    display: contents;
  }

  #button_container {
    display: flex;
    padding-bottom: 10px;
    padding-top: 10px;
    max-width: 600px;
    margin: 5px auto;
  }

  .load-button,
  .save-button {
    flex:1;
    padding-top:5px;
    padding-bottom:5px;
  }

  .delete-button {
    color: #faffff;
    background: #f00;
    border-radius: 0.3rem;
    max-width: 40px;
    max-height: 40px;
    font-size: 10px;
  }

  input#fileid{
    flex-grow: 1;
    padding-top: 5px;
    padding-bottom: 5px;
    background: #222;
    border: 1px solid #333;
    padding-inline: 5px;
    max-width: 225px;
    border-radius: 7px;
    font-family: Arial,sans-serif;
    font-size: 15px;
    color: #ddd;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .gap {
    width: 10px;
  }

  button {
    background: #222;
    border: 1px solid #333;
    padding-inline: 5px;
    width: 100%;
    border-radius: 24px;
    font-family: Arial, sans-serif;
    font-size: 1em;
    color: #ddd;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor:pointer;
  }
  /*
  button:hover,
  input[type="button"]:hover {
    background: #0e70a4;
  }
  */

  .svg-icon {
    vertical-align: middle;
  }

  /*
  .header {
    text-align: center;
  }
  */

  input[type="color"] {
    margin: auto;
  }

  @media (min-width: 768px) {
    .mobile-label {
      display: none;
    }
  }

  @media (max-width: 767px) {
    .grid-container {
      display: flex;
      flex-direction: column;
      text-align: left;
      gap: 0;
    }

    #title_row {
      display: none;
    }

    .grid-item {
      /*display: contents;*/
      width: 100%;
    }

    .grid-row {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 1rem;
      margin-bottom: 1rem;
      border-bottom: 1px solid #ccc; /* Separator */
      padding-bottom: 1rem;
    }

    .delete-button {
      display: flex;
      margin-left: auto;
    }

    .mobile-label {
      font-weight: bold;
      display: inline;
      margin-right: 0.5em;
    }
  }


  </style>
</head>
<body>
  <a id="return_main_menu" href="index.htm"><svg height="24px" width="24px" viewBox="0 0 16 16" id="Layer_1" version="1.1" xml:space="preserve" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><path fill="white" d="M15.45,7L14,5.551V2c0-0.55-0.45-1-1-1h-1c-0.55,0-1,0.45-1,1v0.553L9,0.555C8.727,0.297,8.477,0,8,0S7.273,0.297,7,0.555  L0.55,7C0.238,7.325,0,7.562,0,8c0,0.563,0.432,1,1,1h1v6c0,0.55,0.45,1,1,1h3v-5c0-0.55,0.45-1,1-1h2c0.55,0,1,0.45,1,1v5h3  c0.55,0,1-0.45,1-1V9h1c0.568,0,1-0.437,1-1C16,7.562,15.762,7.325,15.45,7z"/></svg></a>
  <h3 style="margin-bottom: 0">Create Events</h3>
  <h5 style="margin: 0 auto; width: 30vw">
    <details>
      <summary>Info</summary>
        <p style="text-align: left">
        Columns marked with a * are optional.<br>
        Hold the control key while clicking to select or deselect multiple days in Exclude.<br>
        <br>
        Daylight Saving Time transitions:<br>
        Events scheduled during the hour which is skipped when DST starts will occur the following hour. For example, an event scheduled for 2:30 AM moves to 3:30 AM for that morning. An event scheduled at 2 AM moves to 3 AM.<br>
        Events scheduled during the hour which repeats when DST ends will occur within the second occurrence of that hour. For example, an event scheduled for 1:30 AM, skips 1:30 AM EDT and occurs at 1:30 AM EST for that morning. An event at 1 AM will occur 60 minutes and 1 second after 12:59:59 AM. An event at 2 AM will occur 120 minutes and 1 second after 12:59:59 AM.
        </p>
    </details>
  </h5>
  <div id="main_div">
    <div id="button_container">
      <div id="gap1" class="gap"></div>
      <button id="btn_load" class="load-button" onclick="(function(){document.getElementById('local_events_file').click();})()" autocomplete="off"><svg class="svg-icon" style="width:36px;height:36px" viewBox="0 -960 960 960"> <path fill="currentColor" d="M480-320 280-520l56-58 104 104v-326h80v326l104-104 56 58-200 200ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/></svg>&nbsp; <span id="btn_load_text">Load From File</span> </button>
      <input type="file" id="local_events_file" accept=".json" onchange="read_local_events(event)" autocomplete="off" style="display:none" />

      <button id="btn_save" class="save-button" onclick="save()"><svg class="svg-icon" style="width:36px;height:36px" viewBox="0 -960 960 960"> <path id="saveSvg" fill="currentColor" d="M440-320v-326L336-542l-56-58 200-200 200 200-56 58-104-104v326h-80ZM240-160q-33 0-56.5-23.5T160-240v-120h80v120h480v-120h80v120q0 33-23.5 56.5T720-160H240Z"/></svg> &nbsp; <span id="btn_save_text">Save</span> </button>
    </div>
    <div id="events_container" class="grid-container">
        <section id="title_row">
            <label class="item-a">Add/Remove</label>
            <label>Reorder</label>
            <label>Description</label>
            <label>Frequency</label>
            <label>Start Date</label>
            <label>Start Time</label>
            <label>End Date*</label>
            <label>End Time*</label>
            <label>Exclude*</label>
            <label>Visual Pattern</label>
            <label>Color Chooser</label>
            <label>Sound*</label>
            <label>Voice*</label>
        </section>
    </div>
  </div>

  <script>
let base_url = "";
if (window.location.protocol == "file:") {
  // makes for easier debugging.
  // if html is loaded locally, can see the results of editing more easily.
  // otherwise every change to html would require uploading new version to microcontroller.
  base_url = "http://smartbutton.local";
}


async function save() {
  let events_dict = {};

  events_dict["events"] = [];

  let events = document.querySelectorAll("section[data-event]");
  for (let i = 0; i < events.length; i++) {
    let event = events[i];
    let el_keys = event.querySelectorAll("[data-key]");
    let eobj = {};
    let save_color = false;
    for (let j = 0; j < el_keys.length; j++) {
      let el_key = el_keys[j];

      let key = el_key.getAttribute("data-key");
      let value;
      // description
      if (key === "d") {
        // using application/x-www-form-urlencoded percent encodes the json, but ESPAsyncWebServer decodes that back to normal text
        // we want to store the percent encoded description so that it can passed to the tts API
        // since JSON characters that are normally escaped (/ and ") are percent encoded it is not necessary to escape them
        value = encodeURIComponent(el_key.value.trim());
        value = value.replaceAll("%20", "+");
      }

      // frequency
      if (key === "f") {
        value = "o";
        let opt = el_key.options[el_key.selectedIndex];
        if (opt) {
          value = opt.value;
        }
      }

      // start date
      if (key === "sd") {
        //value = [1970, 1, 1];
        value = null;
        // a completely unset date or a partially set date both result in an empty string
        if (el_key.value != "") {
          value = el_key.value.split("-").map((s) => {return parseInt(s, 10)});
        }
      }

      // start time
      if (key === "st") {
        //value = [0, 0, 0];
        value = null;
        if (el_key.value != "") {
          value = el_key.value.split(":").map((s) => {return parseInt(s, 10)});
        }
      }

      // end date -- end date can be left unset by the user to indicate the event should never end
      // if the end date is not set then replace the empty string with 1970-01-01 which the backend uses
      // to represent never ends
      if (key === "ed") {
        value = null;
        if (el_key.value != "") {
          value = el_key.value.split("-").map((s) => {return parseInt(s, 10)});
        }
      }

      // end time
      if (key === "et") {
        value = null;
        if (el_key.value != "") {
          value = el_key.value.split(":").map((s) => {return parseInt(s, 10)});
        }
      }

      // exclude 
      if (key === "e") {
        value = 0;
        let options = el_key.selectedOptions;
        for (let k = 0; k < options.length; k++) {
          let opt = options[k];
          value += (1 << opt.value);
        }
      }

      // pattern
      if (key === "p") {
        value = 0;
        let opt = el_key.options[el_key.selectedIndex];
        if (opt && !isNaN(opt.value)) {
          value = opt.value;
        }
      }

      // sound 
      if (key === "s") {
        value = "";
        let opt = el_key.options[el_key.selectedIndex];
        if (opt) {
          value = opt.value;
        }
      }

      // voice
      if (key === "v") {
        value = "";
        let opt = el_key.options[el_key.selectedIndex];
        if (opt) {
          value = opt.value;
        }
      }

      //stringify() wraps numbers in quotes so wrap numbers in !! to make it easy to remove the quotes.
      //any number that you want to represented as a number in json should have the value set above here. 
      if (value && !isNaN(value)) {
        value = "!!"+value+"!!";
      }

      if (key === "c") {
        value = "0x00000000";
        let opt = el_key.options[el_key.selectedIndex];
        if (opt) {
          value = opt.value;
        }
      }

      eobj[key] = value;
      // TESTING: allows for testing backend defaults
      if (!value) {
        eobj[key] = null;
      }
    }
    events_dict["events"].push(eobj);
  }
  let json = JSON.stringify(events_dict);
  const regex = /"!!(-?[0-9]+\.{0,1}[0-9]*)!!"/g 
  json = json.replace(regex, '$1')
  //console.log(json);
  json = encodeURIComponent(json);

  //console.log(`id=events.json&json=` + json);

  let success = false;
  let sb = document.getElementById("saveSvg");
  sb.setAttribute("fill", "#cccccc");
  let el_btn_save_text = document.getElementById('btn_save_text');
  el_btn_save_text.innerText = "Saving";

  try {
    const response = await fetch(base_url+"/save", {
      method: "POST",
      headers: {
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: "id=/files/events.json&json=" + json
    });
    if (!response.ok) {
      throw new Error('Could not save events.json');
    }
    success = true;
  }
  catch(e) {
    console.error(`save() - ${e}`);
    success = false;
  }

  if (success) {
    sb.setAttribute("fill", "#056b0a");
    el_btn_save_text.innerText = "Saved";
    setTimeout(function(){el_btn_save_text.innerText = "Save";}, 1000);
  }
  else {
    sb.setAttribute("fill", "#6b050c");
    el_btn_save_text.innerText = "Error";
  }

}


async function create_pattern_options() {
  let pattern_options_html = "";
  try {
    const response = await fetch(base_url+"/patterns.json");
    if (!response.ok) {
      throw new Error('Could not fetch patterns.json');
    }
    let data = await response.json();
    //console.log(data);
    options = data["patterns"]
    if (options) {
      for (let i = 0; i < options.length; i++) {
        let option = options[i];
        pattern_options_html += `
     <option value="${option['v']}">${option['n']}</option>`;
      }
    }
  }
  catch(e) {
    console.error(`create_pattern_options() - ${e}`);
  }

  return pattern_options_html;
}


async function create_color_options() {
  let color_options_html = "";
  let color_names = ["Custom", "Black (Off)", "White", "Red", "Orange", "Yellow", "Green", "Aqua", "Blue", "Purple", "Pink"];
  let color_values = ["0x00FFFFFF", "0x00000000", "00x00FFFFFF", "0x00FF0000", "0x00FFA500", "0x00FFFF00", "0x0000FF00", "0x0000FFFF", "0x000000FF", "0x00800080", "0x00FFC0CB"];
  color_options_html += `      <optgroup label="From Color Picker"><option value="${color_values[0]}">${color_names[0]} (${color_values[0].replace('0x00', '#')})</option></optgroup>\r\n`
  color_options_html += `      <optgroup label="Predefined">\r\n`
  for (let i = 1; i < color_names.length; i++) {
    color_options_html += `      <option value="${color_values[i]}">${color_names[i]}</option>\r\n`
  }

  try {
    const response = await fetch(base_url+"/special_colors.json");
    if (!response.ok) {
      throw new Error('Could not fetch special_colors.json');
    }
    let data = await response.json();
    //console.log(data);
    options = data["special_colors"]
    if (options) {
      for (let i = 0; i < options.length; i++) {
        let option = options[i];
        color_options_html += `
     <option value="${option['v']}">${option['n']}</option>`;
      }
    }
  }
  catch(e) {
    console.error(`create_color_options() - ${e}`);
  }

  color_options_html += `      </optgroup>\r\n`
  return color_options_html;
}


async function create_sound_options() {
  let sound_options_html = `
    <option value="">No sound</option>
  <optgroup id="s" label="Sounds">
    <option value="chime01.mp3">Chime 01</option>
    <option value="chime02.mp3">Chime 02</option>
  </optgroup>`;


  try {
    const response = await fetch(base_url+"/files/sound_URLs.json");
    if (!response.ok) {
      throw new Error('Could not fetch sound_URLs.json');
    }
    let data = await response.json();
    options = data["sounds"]
    if (options) {
      sound_options_html += `
  <optgroup id="s" label="URLs">`;
      for (let i = 0; i < options.length; i++) {
        let option = options[i];
        sound_options_html += `
     <option value="${option['u']}">${option['d']}</option>`;
      }
      sound_options_html += `
  </optgroup>`;
    }
  }
  catch(e) {
    console.error(`create_sound_options() - ${e}`);
  }

  return sound_options_html;
}


async function create_voice_options() {
  let voice_options_html = `
    <option value="">No speech</option>`;

  let default_voice;
  try {
    const response = await fetch(base_url+"/get_default_voice");
    if (!response.ok) {
      throw new Error('Could not fetch get_default_voice');
    }
    let data = await response.json();
    //console.log(data);
    default_voice = data["tts_default_voice"]
  }
  catch(e) {
    console.error(`create_voice_options() - ${e}`);
  }

  try {
    const response = await fetch(base_url+"/voicerss.json");
    if (!response.ok) {
      throw new Error('Could not fetch voicerss.json');
    }
    let data = await response.json();
    //console.log(data);
    let optgroups = data["og"];
    if (optgroups) {
        voice_options_html += `
  <optgroup id="v" label="Voices">`;
      for (let i = 0; i < optgroups.length; i++) {
        let optgroup = optgroups[i];
        voice_options_html += `
    <optgroup label="&nbsp;&nbsp;${optgroup['l']}">`;
        let options = optgroup['o'];
        for (let j = 0; j < options.length; j++) {
          let option = options[j];
          if (option['t'] === default_voice) {
            voice_options_html += `
      <option value="${option['v']}" selected="selected">&nbsp;&nbsp;${option['t']}</option>`;
          }
          else {
            voice_options_html += `
      <option value="${option['v']}">&nbsp;&nbsp;${option['t']}</option>`;
          }
        }
        voice_options_html += `
    </optgroup>`;
      }
        voice_options_html += `
  </optgroup>`;
    }
  }
  catch(e) {
    console.error(`create_voice_options() - ${e}`);
  }

  return voice_options_html;
}


function handle_reorder(num_id, direction) {
  let section = document.getElementById(`e${num_id}`);
  let selects = section.querySelectorAll("select");
  let selected_indexes = [];
  for (let select of selects) {
    selected_indexes.push(select.selectedIndex);
  }

  let new_section = document.createDocumentFragment();
  new_section.appendChild(section.cloneNode(true));
  selects = new_section.querySelectorAll("select");
  for (let i in selects) {
    selects[i].selectedIndex = selected_indexes[i];
  }

  let events_container = document.getElementById("events_container");

  if (direction === "up") {
    if (section.previousElementSibling.id != "title_row") {
      events_container.insertBefore(new_section, section.previousElementSibling);
      section.remove();
    }
  }
  else if (direction === "down" && section.nextElementSibling.id != "add_event_buttons_div") {
    events_container.insertBefore(new_section, section.nextElementSibling.nextElementSibling);
    section.remove();
  }
}


function handle_exclude_select(el_changed, event) {
  //console.log(event.type);
  if (event.type == "mouseenter") {
    // add a little delay to prevent showing options if mouse cursor was just passing over and not hovering over element
    el_changed.timeout_id = setTimeout(function(){el_changed.style.height = "155px"; el_changed.style.overflow = "show"; el_changed.style.zIndex = "1";}, 200);
  }

  if (event.type == "mouseleave") {
    clearTimeout(el_changed.timeout_id);
    let el_selects = document.querySelectorAll('select[data-key="e"]');
    for (let i = 0; i < el_selects.length; i++) {
      let el_select = el_selects[i];
      el_select.style.height = "100%";
      el_select.style.overflow = "hidden";
      el_select.style.zIndex = "auto";
    }
  }

  if (event.type == "change") {
    let options = el_changed.options;
    for (let i = 0; i < options.length; i++) {
      let option = options[i];
      option.innerHTML = option.innerHTML.replace("☑", "☐");
      if (option.selected) {
        option.innerHTML = option.innerHTML.replace("☐", "☑");
      }
    }
  }
}


function handle_color_picker(el_changed) {
  let i = parseInt(el_changed.id.replace("e", "").replace("cp", ""));
  let color_select = document.getElementById(`e${i}c`);
  let custom_option = color_select.options[0];
  let color = el_changed.value.replace("#", "").toUpperCase();
  custom_option.innerHTML = `Custom (${el_changed.value.toUpperCase()})`
  custom_option.value = `0x00${color}`
  custom_option.selected = true;
  color_select.dispatchEvent(new Event('change'));
}


function handle_color_select(el_changed) {
  let i = parseInt(el_changed.id.replace("e", "").replace("c", ""));
  let color = `#${el_changed.value.slice(4)}`;
  let color_picker = document.getElementById(`e${i}cp`);
  color_picker.value = color;
  let overlay_color = document.getElementById(`e${i}ol`);
  overlay_color.innerText = ""; 
  if (el_changed.selectedOptions[0].innerHTML === "Rainbow") {
    //overlay_color.style.background = "linear-gradient(90deg, red 0%, orange 14.29%, yellow 28.57%, green 42.86%, aqua 57.14%, blue 71.43%, purple 85.71%, pink 100%)";
    overlay_color.style.backgroundImage = "linear-gradient(90deg, red, orange, yellow, green, aqua, blue, purple, pink)";
  }
  else if (el_changed.selectedOptions[0].innerHTML.indexOf(" and ") > -1) {
    let color1 = el_changed.selectedOptions[0].innerHTML.split(" and ")[0];
    let color2 = el_changed.selectedOptions[0].innerHTML.split(" and ")[1];
    overlay_color.style.backgroundImage = `linear-gradient(90deg, ${color1}, ${color2})`; 
  }
  else if (el_changed.selectedOptions[0].innerHTML === "?????") {
    overlay_color.innerText = "?????";
    overlay_color.style.backgroundColor = "white"; 
    overlay_color.style.backgroundImage = "none"; 
  }
  else {
    overlay_color.style.background = "none";
  }
}

let event_html_template = "";
async function create_event_html_template() {
  let exclude_options_html = "";
  let days = ["☐ Sunday", "☐ Monday", "☐ Tuesday", "☐ Wednesday", "☐ Thursday", "☐ Friday", "☐ Saturday"];
  for (let i = 0; i < days.length; i++) {
    exclude_options_html += `      <option value="${i}">${days[i]}</option>\r\n`
  }

  let pattern_options_html = await create_pattern_options();
  let color_options_html = await create_color_options();

  let sound_options_html = await create_sound_options();
  let voice_options_html = await create_voice_options();

  event_html_template = `
<section id="e!!EVENT_NUM!!" class="grid-row" data-event="e!!EVENT_NUM!!">
    <div class="grid-item">
      <input type="button" value="&#10006;" class="delete-button" onclick=(function(){document.getElementById("e!!EVENT_NUM!!").remove()})() />
    </div>

    <div class="grid-item">
      <input type="button" value="↑" onclick="handle_reorder(!!EVENT_NUM!!, 'up')" />
      <input type="button" value="↓" onclick="handle_reorder(!!EVENT_NUM!!, 'down')" />
    </div>

    <div class="grid-item">
      <span class="mobile-label">Description:</span>
      <input id="e!!EVENT_NUM!!d" type="text" data-key="d" value="" maxlenght=100 autocomplete="off" />
    </div>
    <div class="grid-item">
      <span class="mobile-label">Frequency:</span>
      <select id="e!!EVENT_NUM!!f" data-key="f" autocomplete="off">
        <option value="o">Once</option>
        <!--option value="h">Hourly</option-->
        <option value="d">Daily</option>
        <option value="w">Weekly</option>
        <option value="m">Monthly</option>
        <option value="y">Yearly</option>
        <!--option value="s">Start of Month</option-->
        <!--option value="e">End of Month</option-->
      </select>
    </div>
    <div class="grid-item">
      <span class="mobile-label">Start Date:</span>
      <input id="e!!EVENT_NUM!!sd" type="date" data-key="sd" value="" min="" max="" />
    </div>
    <div class="grid-item">
      <span class="mobile-label">Start Time:</span>
      <input id="e!!EVENT_NUM!!st" type="time" data-key="st" value="" min="" max="" />
    </div>
    <div class="grid-item">
      <span class="mobile-label">End Date*:</span>
      <input id="e!!EVENT_NUM!!ed" type="date" data-key="ed" value="" min="" max="" />
    </div>
    <div class="grid-item">
      <span class="mobile-label">End Time*:</span>
      <input id="e!!EVENT_NUM!!et" type="time" data-key="et" value="" min="" max="" />
    </div>

    <div class="grid-item" style="display: contents"> <!--wrapping exclude in a div breaks its minimize behavior unless "display: contents" is used-->
      <span class="mobile-label">Exclude:</span>
      <select id="e!!EVENT_NUM!!e" data-key="e" autocomplete="off" multiple size="7" style="overflow:hidden" onmouseenter="handle_exclude_select(this, event)" onmouseleave="handle_exclude_select(this, event)" onchange="handle_exclude_select(this, event)">;
${exclude_options_html}
      </select>
    </div>

    <div class="grid-item">
      <span class="mobile-label">Visual Pattern:</span>
      <select id="e!!EVENT_NUM!!p" data-key="p" autocomplete="off">
${pattern_options_html}
      </select>
    </div>
    <div class="grid-item">
      <span class="mobile-label">Color Chooser:</span>
      <div style="display:flex; width: 100%">
        <div style="position:relative; contain: paint">
          <input id="e!!EVENT_NUM!!cp" type="color" autocomplete="off" value="#FFFFFF" oninput="handle_color_picker(this)" />
          <div id="e!!EVENT_NUM!!ol" style="position: absolute; top: 0; left: 0; margin: 0; border: none; width: 100%; height: 100%; pointer-events: none; color: black; display: flex; justify-content: center; align-content: center; flex-direction: column;"></div>
        </div>
        <select id="e!!EVENT_NUM!!c" data-key="c" autocomplete="off" style="flex-grow:1" onchange="handle_color_select(this)">
${color_options_html}
        </select>
      </div>
    </div>
    <div class="grid-item">
      <span class="mobile-label">Sound*:</span>
      <select id="e!!EVENT_NUM!!s" data-key="s" autocomplete="off">
${sound_options_html}
      </select>
    </div>
    <div class="grid-item">
      <span class="mobile-label">Voice*:</span>
      <select id="e!!EVENT_NUM!!v" data-key="v" autocomplete="off">
${voice_options_html}
      </select>
    </div>
</section>`;
}


const adjectives = [
  "Winsome", "Luminous", "Feral", "Ethereal", "Zealous",
  "Mirthful", "Arcane", "Velvety", "Savage", "Whimsical",
  "Gilded", "Dusky", "Frosty", "Roguish", "Serene",
  "Vivid", "Breezy", "Sublime", "Cryptic", "Jaunty",
  "Radiant", "Moody", "Brisk", "Twinkling", "Feisty"
];

const nouns = [
  "Dragon", "Phoenix", "Griffin", "Unicorn", "Kraken",
  "Basilisk", "Chimera", "Hydra", "Centaur", "Manticore",
  "Siren", "Harpy", "Pixie", "Elf", "Goblin",
  "Sprite", "Gnome", "Djinn", "Wendigo", "Banshee",
  "Sphinx", "Nymph", "Pegasus", "Wyvern", "Valkyrie"
];


async function add_basic_event(is_new, value, unit) {
  add_basic_event.event_num = add_basic_event.event_num || 0;
  let i = add_basic_event.event_num; 
  let events_container = document.getElementById("events_container");
  let event_html = event_html_template.replaceAll("!!EVENT_NUM!!", i); 
  //events_container.insertAdjacentHTML("beforeend", event_html);
  let add_event_buttons_div = document.getElementById("add_event_buttons_div");
  //events_container.insertBefore(event_html, add_event_button);
  add_event_buttons_div.insertAdjacentHTML("beforebegin", event_html);

  if (is_new) {
    let adjective = adjectives[Math.floor(Math.random() * adjectives.length)];
    let noun = nouns[Math.floor(Math.random() * nouns.length)];
    document.getElementById(`e${i}d`).value = `Event ${adjective} ${noun}`;

    //privacy.resistFingerprinting prevents this from working correctly
    //const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    //console.log(timezone);
  
    let data;
    try {
      const response = await fetch(base_url+"/new_time", {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: `value=${value}&unit=${unit}`
      });
      if (!response.ok) {
        throw new Error('Could not POST to /new_time');
      }
      data = await response.json();
    }
    catch(e) {
      data = {"date":"1970-01-01", "h":"0", "m":"0", "s":"0"};
      console.error(`add_basic_event() - ${e}`);
    }

    console.log(data);

    document.getElementById(`e${i}sd`).value = data["date"];
    document.getElementById(`e${i}st`).value = data["h"].padStart("2", "0") + ":" + data["m"].padStart("2", "0") + ":" + data["s"].padStart("2", "0");
    document.getElementById(`e${i}ed`).value = "";
    document.getElementById(`e${i}et`).value = "";

    let pattern_select = document.getElementById(`e${i}p`);
    let random_pattern_option_index = Math.floor(Math.random() * pattern_select.options.length);
    let pattern_option = pattern_select.options[random_pattern_option_index];
    pattern_option.selected = true;

    let color_select = document.getElementById(`e${i}c`);

    // want to increase the odds of getting a custom random color over getting a color from the list
    // to do that make random_color_option_index bigger than the number of options
    // then all random_color_option_index results that are greater than the length are set to 0 which results in a custom random color
    let random_color_option_index = Math.floor(Math.random() * 1.5 * color_select.options.length);
    random_color_option_index = (random_color_option_index < color_select.options.length) ? random_color_option_index : 0;
    // never randomly select black or white (too boring)
    random_color_option_index = (random_color_option_index > 2) ? random_color_option_index : 0;
    let color_option = color_select.options[random_color_option_index];
    color_option.selected = true;
    if (random_color_option_index === 0) {
      //let random_hex_color = Math.floor(Math.random() * 16777216).toString(16); //16777216 = 16777215 + 1 = 0xFFFFFF +1, need +1 so 0xFFFFFF included in the range
      let random_hex_color = (Math.floor(Math.random() * (16777216 - 8947848)) + 8947848).toString(16); // RGB hex numbers as strings from #888888 to #FFFFFF
      random_hex_color = random_hex_color.toUpperCase();
      color_select.options[0].value = `0x00${random_hex_color}`;
      color_select.options[0].innerHTML = `Custom (#${random_hex_color})`
    }
    color_select.dispatchEvent(new Event('change'));

    //DEBUG: for making it easier to add test events that have both sound and voice
    let sound_select = document.getElementById(`e${i}s`);
    sound_select.options[1].selected = true;
  }

  i++
  add_basic_event.event_num = i; 
}


function read_local_events(event) {
  const file = event.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      events = data["events"];

      load_events(events);
    }
    catch (err) {
      console.error("Invalid JSON file:", err);
      alert("Failed to parse JSON. Please check the file format.");
    }
  };
  reader.readAsText(file);
}


async function fetch_remote_events() {
  let events;
  try {
    const response = await fetch(base_url+"/files/events.json");
    if (!response.ok) {
      throw new Error('Could not fetch events.json');
    }
    let data = await response.json();
    //console.log(data);
    events = data["events"]
  }
  catch(e) {
    console.error(`fetch_events() - ${e}`);
  }
  return events;
}

let en = 0;
function load_events(events) {
  //console.log(events);

  if (events) {
    for (let i = 0; i < events.length; i++, en++) {
      add_basic_event(false);

      // customize events using data from events.json

      let description = "";
      if (events[i]["d"]) {
        description = decodeURIComponent(events[i]["d"].replaceAll("+", "%20"));
      }
      document.getElementById(`e${en}d`).value = description;
      document.getElementById(`e${en}f`).value = events[i]["f"];

      if (events[i]["sd"]) {
        let start_date = String(events[i]["sd"][0]) + "-" + String(events[i]["sd"][1]).padStart("2", "0") + "-" + String(events[i]["sd"][2]).padStart("2", "0");
        document.getElementById(`e${en}sd`).value = start_date;
      }

      if (events[i]["st"]) {
        let start_time = String(events[i]["st"][0]).padStart("2", "0") + ":" + String(events[i]["st"][1]).padStart("2", "0") + ":" + String(events[i]["st"][2]).padStart("2", "0");
        document.getElementById(`e${en}st`).value = start_time;
      }

      if (events[i]["ed"]) {
        let end_date = String(events[i]["ed"][0]) + "-" + String(events[i]["ed"][1]).padStart("2", "0") + "-" + String(events[i]["ed"][2]).padStart("2", "0");
        document.getElementById(`e${en}ed`).value = end_date;
      }

      if (events[i]["et"]) {
        let end_time = String(events[i]["et"][0]).padStart("2", "0") + ":" + String(events[i]["et"][1]).padStart("2", "0") + ":" + String(events[i]["et"][2]).padStart("2", "0");
        document.getElementById(`e${en}et`).value = end_time;
      }

      if (events[i]["e"]) {
        let exclude_select = document.getElementById(`e${en}e`);
        let exclude = parseInt(events[i]["e"]);
        for (let j = 0; exclude > 0 && j < exclude_select.options.length; j++) {
          let option = exclude_select.options[j];
          option.innerHTML = option.innerHTML.replace("☑", "☐");
          let selected = "";
          let mask = 1 << j;
          if ((exclude & mask) > 0) {
            //console.log(`exclude: ${exclude}`);
            //console.log(`j: ${j}`);
            option.selected = true;
            option.innerHTML = option.innerHTML.replace("☐","☑");
          }
        }
      }

      let pattern_select = document.getElementById(`e${en}p`);
      for (let j = 0; j < pattern_select.options.length; j++) {
        let option = pattern_select.options[j];
        if (option.value.indexOf(events[i]["p"]) != -1) {
          option.selected = true;
          break;
        }
      }

      let event_color = "0x00000000";
      if (events[i]["c"]) {
        event_color = events[i]["c"];
      }
      let color_select = document.getElementById(`e${en}c`);
      let is_color_selected = false;
      for (let j = 0; j < color_select.options.length; j++) {
        let option = color_select.options[j];
        if (option.value == event_color) {
          is_color_selected = true;
          option.selected = true;
          break;
        }
      }
      if (!is_color_selected) {
        if (event_color.substring(0, 4) === "0x00") {
          color_select.options[0].value = event_color;
          event_color = event_color.replace("0x00", "").toUpperCase();
          color_select.options[0].innerHTML = `Custom (#${event_color})`
        }
      }
      color_select.dispatchEvent(new Event('change'));

      let sound_select = document.getElementById(`e${en}s`);
      for (let j = 0; j < sound_select.options.length; j++) {
        let option = sound_select.options[j];
        if (option.value.indexOf(events[i]["s"]) != -1) {
          option.selected = true;
          break;
        }
      }

      let voice_select = document.getElementById(`e${en}v`);
      for (let j = 0; j < voice_select.options.length; j++) {
        let option = voice_select.options[j];
        if (option.value.indexOf(events[i]["v"]) != -1) {
          option.selected = true;
          break;
        }
      }
    } // end while
  }
}


async function get_timezone() {
  let iana_tz = "UTC";
  let is_default_tz = true;
 
  let message = document.createElement("div");

  try {
    // TODO cache busting necessary for Chrome?
    const timestamp = Date.now();
    const response = await fetch(`${base_url}/get_timezone?${timestamp}`);
    if (!(response.ok || response.status == 404)) {
      throw new Error('Could not fetch get_timezone');
    }
    let data = await response.json();
    //console.log(data);
    iana_tz = data["iana_tz"];
    is_default_tz = data["is_default_tz"];
  }
  catch(e) {
    console.error(`get_timezone() - ${e}`);
  }

  if (is_default_tz) {
    message.innerHTML = "<b style='color:red'>Warning: timezone is not set. All times are in UTC. Please visit configuration page to set timezone.</b>";
  }

  try {
    // TODO cache busting necessary for Chrome?
    const timestamp = Date.now();
    const response = await fetch(`${base_url}/get_time?${timestamp}`);
    if (!(response.ok || response.status == 404)) {
      throw new Error('Could not fetch /get_time');
    }
    let data = await response.text();
    console.log(data);
    if (data) {
      if (message.innerHTML != "") {
        message.innerHTML += "<br>";
      }
      message.innerHTML += `Button's local date and time at page load: ${data} ${iana_tz}`;
    }
    else {
      message.innerHTML = `<b style='color:red'>Error: Could not get time.</b>`;
    }
  }
  catch(e) {
    console.error(`get_timezone() - ${e}`);
  }

  let button_container = document.getElementById("button_container");
  let main_div = document.getElementById("main_div");
  main_div.insertBefore(message, button_container);
}



async function run() {
  await create_event_html_template();
  let events_container = document.getElementById("events_container");
  let add_event_buttons_div = document.createElement("div");
  add_event_buttons_div.id = "add_event_buttons_div";

  let add_event_buttons = '<span class="mobile-label">New Event:</span>';
  let query_string = window.location.search;
  let url_params = new URLSearchParams(query_string);
  let debug = url_params.get("debug")
  if (debug != null) {
    add_event_buttons += '<input type="button" value="+15s"   onclick="add_basic_event(true, 15, `s`)" />';
    add_event_buttons += '<input type="button" value="+30s"   onclick="add_basic_event(true, 30, `s`)" />';
    add_event_buttons += '<input type="button" value="+2m"  onclick="add_basic_event(true, 2, `m`)" />';
    add_event_buttons += '<input type="button" value="+5m"  onclick="add_basic_event(true, 5, `m`)" />';
    add_event_buttons += '<input type="button" value="+10m"  onclick="add_basic_event(true, 10, `m`)" />';
  }
  add_event_buttons += '<input type="button" value="+30m" onclick="add_basic_event(true, 30, `m`)" />';
  add_event_buttons += '<input type="button" value="+1h"  onclick="add_basic_event(true, 1, `h`)" />';
  add_event_buttons += '<input type="button" value="+1d" onclick="add_basic_event(true, 1, `d`)" />'; // what happens if a day has more than 24 hours, (i.e. fall back, DST ends)
  
  add_event_buttons_div.innerHTML = add_event_buttons;
  events_container.append(add_event_buttons_div);
  let events = await fetch_remote_events();
  load_events(events);
  await get_timezone();
}


function quick_add_event(e) {
  if (e.ctrlKey && e.code === 'ArrowDown') {
    add_basic_event(true, 30, `s`);
  }
}

window.addEventListener("load", run);

window.addEventListener("keyup", quick_add_event);

  </script>

</body>
</html>
